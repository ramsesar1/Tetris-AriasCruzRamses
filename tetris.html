<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atomic tetris</title>
<style>
  canvas{
    background-color: #000;
    display: block;
    margin: 0 auto;
  }
  </style>
</head>
<body>
  <canvas id="tetris" width="300" height="600"></canvas>

  <script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');

    const rows = 20;
    const cols = 10;
    const block_size = 30;


    //color temporal de las piezas
    const colors = [
      null,
      'cyan','blue','orange','yellow','green','purple','red'
    ];

    //piezas
    const pieces =[
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], //pieza I
    [[0,2,0],[2,2,2],[0,0,0]], //pieza T
    [[3,3],[3,3]], // pieza cubo
    [[0,4,4],[4,4,0],[0,0,0]], // pieza S
    [[5,5,0],[0,5,5],[0,0,0]], // pieza Z
    [[6,6,6],[6,0,0],[0,0,0]], // pieza L
    [[7,7,7],[0,0,7],[0,0,0]], // pieza J
    ];

    //rotacion de piezas
    function rotate(matrix){
      const N = matrix.length;
      const M = matrix[0].length;
      const result = [];

      for (let i = 0; i < M; i++){
        result.push(new Array(N).fill(0));
      }

//      for (let i = 0; i < N; i++){
//        result.push(new Array(N).fill(0));
//      }
      for(let y = 0; y < N; y++){
        for(let x = 0; x < N; x++){
          result[x][N - y - 1] = matrix[y][x];
        }
      }
      return result;
    }

    //Crear pieza
    function createPiece(){
      const type = Math.floor(Math.random() * pieces.length);
      return {
        matrix: pieces[type],
        pos: {x: Math.floor(cols/2)-1,y:0},
      };
    }

    //dibujar la pieza
    function drawPiece(piece){
      piece.matrix.forEach((row,y) => {
        row.forEach((value,x) => {
          if (value !== 0) {
            ctx.fillStyle = colors[value];
            ctx.fillRect((piece.pos.x+x)*block_size,(piece.pos.y + y)* block_size, block_size, block_size);

          }
        });
      });
    }

    //Agrega pieza
    function merge(grid,piece){
      piece.matrix.forEach((row, y) => {
        row.forEach((value, x)=> {
          if(value !== 0){
            grid[piece.pos.y + y][piece.pos.x + x] = value;
          }
        });
      });
    }



    //limpiar el canvas
    function clearCanvas(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }



    //colision de piezas
    function collide(grid, piece){
      for (let y = 0; y < piece.matrix.length; y++){
        for(let x = 0; x < piece.matrix[y].length; x++){
          if (piece.matrix[y][x] !== 0 && 
            (grid[piece.pos.y + y] && grid[piece.pos.y + y][piece.pos.x + x]) !== 0){
              return true;
            }
        }
      }
      return false;
    }




    //Controles
    document.addEventListener('keydown',event =>{
      if (event.key === 'ArrowLeft'){
        move(-1);
      }
        else if(event.key === 'ArrowRight'){
          move(1);
        }
        else if(event.key === 'ArrowDown'){
          drop();
        }
        else if(event.key === 'ArrowUp'){
          player.matrix = rotate(player.matrix);
          if(collide(grid, player)){
            player.matrix = rotate(player.matrix)
          }
        }
    });




    //movimiento horizontal
    function move(dir){
      player.pos.x += dir;
      if (collide(grid, player)){
        player.pos.x -= dir;
      }
    }


    //eliminacion de hileras
    
    function sweep(grid){
      let linesCrealed = 0;
      for (let y = grid.length -1; y >= 0; y--){
        let isRowComplete = true;
        for(let x = 0; x<grid[y].length; x++){
          if(grid[y][x] === 0){
            isRowComplete = false;
            break;
          }
        }
        if (isRowComplete){
        const row = grid.splice(y,1)[0].fill(0);
        grid.unshift(row);
        linesCrealed++;
        y++;
      }
    }
    return linesCrealed;
    }


    //movimiento vertical
    function drop() {
      player.pos.y++;
      if (collide(grid,player)){
        player.pos.y--;
        merge(grid,player);
        sweep(grid);
        player = createPiece();
      }
      dropCounter = 0;
    }

    //-----------------------------------actualizar juego--------------------*//

    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;

    function update(time = 0){
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;

      if (dropCounter > dropInterval){
        drop();
      }

      clearCanvas();
      drawGrid(grid);

      drawPiece(player);


      requestAnimationFrame(update);

    }




    //-----------------------------------cuadricula--------------------*//



    //cuadricula
    function createGrid(){
      const grid = [];
      while (grid.length < rows){
        grid.push(new Array(cols).fill(0));
      }
      return grid;
    }

    function drawGrid(grid){
      grid.forEach((row, y) => {
        row.forEach((value, x) =>{
          if(value !== 0){
            ctx.fillStyle = colors[value];
            ctx.fillRect(x*block_size, y * block_size, block_size, block_size);
          }
        });
      });
    }


    //iniciar el juego
    let grid = createGrid();
    let player = createPiece();
    
    update();
  </script>
  
</body>
</html>