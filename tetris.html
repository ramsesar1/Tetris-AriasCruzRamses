<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atomic tetris</title>
  <link rel="stylesheet" href ="tetris.css">
<style>
  canvas{
    background-color: #000;
    display: block;
    margin: 0 auto;
  }
  </style>
</head>
<body>
  <canvas id="tetris" width="300" height="600"></canvas>
  <canvas id="next" width="120" height="120"></canvas>
  <canvas id="hold" width="120" height="120"></canvas>
  <canvas id="counter" width="180" height="120"></canvas>

  <audio id="background-music" src="ingame.mp3" loop></audio>

  <script>
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const backgroundMusic = document.getElementById('background-music');

    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');

    const holdCanvas = document.getElementById('hold');
    const holdCtx = holdCanvas.getContext('2d');

    const counterCanvas = document.getElementById('counter');
    const counterCtx = counterCanvas.getContext('2d');

    const rows = 20;
    const cols = 10;
    const block_size = 30;


    //color temporal de las piezas
    const colors = [
      null,
      'cyan','blue','orange','yellow','green','purple','red'
    ];

    //piezas
    const pieces =[
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], //pieza I
    [[0,2,0],[2,2,2],[0,0,0]], //pieza T
    [[3,3],[3,3]], // pieza cubo
    [[0,4,4],[4,4,0],[0,0,0]], // pieza S
    [[5,5,0],[0,5,5],[0,0,0]], // pieza Z
    [[6,6,6],[6,0,0],[0,0,0]], // pieza L
    [[7,7,7],[0,0,7],[0,0,0]], // pieza J
    ];


    //conteo de tetris en 0
    let tetrisCount = 0;

    //contador placeholder
    function drawCounter(){
      counterCtx.clearRect(0,0,counterCanvas.width, counterCanvas.height);
      counterCtx.fillStyle = 'white';
      counterCtx.font = '24px Arial';
      counterCtx.fillText(`Tetris: ${tetrisCount}`, 10, 30);
    }

    //rotacion de piezas
    function rotate(matrix){
      const N = matrix.length;
      const M = matrix[0].length;
      const result = [];

      for (let i = 0; i < M; i++){
        result.push(new Array(N).fill(0));
      }

//      for (let i = 0; i < N; i++){
//        result.push(new Array(N).fill(0));
//      }
      for(let y = 0; y < N; y++){
        for(let x = 0; x < N; x++){
          result[x][N - y - 1] = matrix[y][x];
        }
      }
      return result;
    }

    //Crear pieza
    function createPiece(){
      const type = Math.floor(Math.random() * pieces.length);
      return {
        matrix: pieces[type],
        pos: {x: Math.floor(cols/2)-1,y:0},
      };
    }

    //----------------------------------Siguiente pieza----------------------*//

    //dibujar pieza siguiente
    function drawNextPiece(piece){
      //limpiar el canvas de la siguiente
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);


      piece.matrix.forEach((row, y) => {
        row.forEach((value, x)=>{
          if(value !== 0){
            nextCtx.fillStyle = colors[value];
            nextCtx.fillRect(x*block_size, y*block_size, block_size, block_size);
          }
        });
      });
    }

    //dibujar la pieza
    function drawPiece(piece){
      piece.matrix.forEach((row,y) => {
        row.forEach((value,x) => {
          if (value !== 0) {
            ctx.fillStyle = colors[value];
            ctx.fillRect((piece.pos.x+x)*block_size,(piece.pos.y + y)* block_size, block_size, block_size);

          }
        });
      });
    }

    //Agrega pieza
    function merge(grid,piece){
      piece.matrix.forEach((row, y) => {
        row.forEach((value, x)=> {
          if(value !== 0){
            grid[piece.pos.y + y][piece.pos.x + x] = value;
          }
        });
      });
    }



    //limpiar el canvas
    function clearCanvas(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }



    //colision de piezas
    function collide(grid, piece){
      for (let y = 0; y < piece.matrix.length; y++){
        for(let x = 0; x < piece.matrix[y].length; x++){
          if (piece.matrix[y][x] !== 0 && 
            (grid[piece.pos.y + y] && grid[piece.pos.y + y][piece.pos.x + x]) !== 0){
              return true;
            }
        }
      }
      return false;
    }




    //Controles
    document.addEventListener('keydown',event =>{
      if (event.key === 'ArrowLeft'){
        move(-1);
      }
        else if(event.key === 'ArrowRight'){
          move(1);
        }
        else if(event.key === 'ArrowDown'){
          drop();
        }
        else if(event.key === 'ArrowUp'){
          player.matrix = rotate(player.matrix);
          if(collide(grid, player)){
            player.matrix = rotate(player.matrix)
          }
        } else if (event.key === 'c' || event.key === 'C'){
          holdPiece();
        }
    });




    //movimiento horizontal
    function move(dir){
      player.pos.x += dir;
      if (collide(grid, player)){
        player.pos.x -= dir;
      }
    }


    //eliminacion de hileras
    
    function sweep(grid){
      let linesCrealed = 0;
      for (let y = grid.length -1; y >= 0; y--){
        let isRowComplete = true;
        for(let x = 0; x<grid[y].length; x++){
          if(grid[y][x] === 0){
            isRowComplete = false;
            break;
          }
        }
        if (isRowComplete){
        const row = grid.splice(y,1)[0].fill(0);
        grid.unshift(row);
        linesCrealed++;
        y++;
      }
    }
    if (linesCrealed === 4){
      tetrisCount++;
      addPowerUp();
      drawCounter();
    }

    drawPowerUps();

    return linesCrealed;
    }


    //movimiento vertical
    function drop() {
      player.pos.y++;
      if (collide(grid,player)){
        player.pos.y--;
        merge(grid,player);
        sweep(grid);

        
        player = nextPiece;

        nextPiece = createPiece();

        drawNextPiece(nextPiece);

        canHold = true;
      }
      dropCounter = 0;
    }
    

    //----------------------------------Contenedor de piezas----------------------------*//

    let heldPiece = null;
    let canHold = true;

    function holdPiece(){
      if(canHold){
        if(heldPiece === null){
          heldPiece = player;
          player = nextPiece;
          nextPiece = createPiece();
        } else {
          const temp = player;
          player = heldPiece;
          heldPiece = temp;
        }
        player.pos = {x: Math.floor(cols/2)-1, y:0};
        canHold = false;
        drawHeldPiece();
      }
    }

    function drawHeldPiece(){
      holdCtx.clearRect(0,0, holdCanvas.width, holdCanvas.height);
      if (heldPiece){
        heldPiece.matrix.forEach((row, y) => {
          row.forEach((value,x) => {
            if(value !== 0){
              holdCtx.fillStyle = colors[value];
              holdCtx.fillRect(x*block_size, y*block_size, block_size, block_size, block_size)
            }
          });
        });
      }
    }



    //-----------------------------------actualizar juego--------------------*//

    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let gameTime = 0;
    let speedIncreaseInterval = 3 * 60 * 1000;

    function update(time = 0){
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      gameTime += deltaTime;

      if (dropCounter > dropInterval){
        drop();
      }

      if (Math.floor(gameTime / speedIncreaseInterval) > Math.floor((gameTime - deltaTime)/ speedIncreaseInterval)){
        increaseSpeed();
      }

      clearCanvas();
      drawGrid(grid);
      drawPiece(player);
      drawHeldPiece(nextPiece);
      drawHeldPiece();

      requestAnimationFrame(update);

    }


    //aumentar velocidad

    function increaseSpeed(){
      if (dropInterval > 100){
        dropInterval *= 0.9;
        console.log('Velocidad aumentada:', dropInterval);
      }
    }
    



    //---------------------------------logica de musica------------------------------------**//

    let musicStarted = false;
    let canPlayMusic = true;

    function attemptPlayMusic() {
      if (canPlayMusic && !musicStarted) {
        backgroundMusic.play().then(() => {
          musicStarted = true;
          console.log('Game music started successfully');
        }).catch(error => {
          console.error('Error playing game music:', error);
          canPlayMusic = false;
          addInteractionListeners();
        });
      }
    }

    function addInteractionListeners() {
      ['click', 'touchstart', 'keydown', 'mousemove'].forEach(eventType => {
        document.addEventListener(eventType, playMusicOnInteraction, { once: true });
      });
    }

    function playMusicOnInteraction() {
      if (!musicStarted) {
        canPlayMusic = true;
        attemptPlayMusic();
      }
    }

    function removeInteractionListeners() {
      ['click', 'touchstart', 'keydown', 'mousemove'].forEach(eventType => {
        document.removeEventListener(eventType, playMusicOnInteraction);
      });
    }

    window.addEventListener('load', attemptPlayMusic);

    backgroundMusic.addEventListener('play', () => {
      musicStarted = true;
      removeInteractionListeners();
    });

    //------------------------------------Bomba------------------------------------//

    let powerUpCount = 0;
    const maxPowerUps = 3;

    function drawPowerUps(){
      counterCtx.clearRect(0,50,counterCanvas.width, counterCanvas.height);
      
      for(let i = 0; i< powerUpCount; i++){
        counterCtx.fillStyle = 'red';
        counterCtx.fillRect(10 + i * 40, 50, 30, 30,);
      }
    }

    function addPowerUp(){
      if (powerUpCount < maxPowerUps){
        powerUpCount++;
        drawPowerUps();
      }
    }

    function usePowerUp(){
      if(powerUpCount > 0){
        powerUpCount--;
        clearGrid();
        drawPowerUps();
      }
    }

    //limpia la cuadricula con la bomba
    function clearGrid(){
      grid.forEach((row, y) => {
        row.fill(0);
      });
    }

    //activar bomba
    document.addEventListener('keydown', event => {
      if (event.key === 'b' || event.key === 'B'){
        usePowerUp();
      }
    });




    //-----------------------------------cuadricula--------------------*//



    //cuadricula
    function createGrid(){
      const grid = [];
      while (grid.length < rows){
        grid.push(new Array(cols).fill(0));
      }
      return grid;
    }

    function drawGrid(grid){
      grid.forEach((row, y) => {
        row.forEach((value, x) =>{
          if(value !== 0){
            ctx.fillStyle = colors[value];
            ctx.fillRect(x*block_size, y * block_size, block_size, block_size);
          }
        });
      });
    }


    //iniciar el juego
    let grid = createGrid();
    let player = createPiece();
    let nextPiece = createPiece();
    
    attemptPlayMusic();

    drawNextPiece(nextPiece);
    drawHeldPiece();
    drawCounter();
    drawPowerUps();
    update();
  </script>
  
</body>
</html>